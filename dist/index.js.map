{"version":3,"sources":["../src/index.ts"],"sourcesContent":["import { IncomingMessage, ServerResponse } from \"http\";\nimport * as http from 'http';\n\ntype Handler = (req: IncomingMessage, res: ServerResponse, next: () => void) => void;\n\nexport interface Endpoint {\n    url: string;\n    handlers: Array<Handler>;\n}\n\ndeclare module 'http' {\n    interface IncomingMessage {\n        params: { [key: string]: string };\n        body: { [key: string]: any };\n    }\n}\n\nclass Router {\n    private routes: Map<string, Endpoint[]>;\n\n    constructor(routers: Router[] = []) {\n        const flatRoutes = routers.flatMap(router => [...router.routes.entries()]);\n        this.routes = new Map(flatRoutes);\n    }\n\n    public async use(req: IncomingMessage, res: ServerResponse) {\n        const methodRoutes = this.routes.get(req.method || \"\");\n        if (methodRoutes) {\n            for (const endPoint of methodRoutes) {\n                if (this.match(endPoint.url, req)) {\n                    await this.runHandlers(endPoint.handlers, req, res);\n                    return;\n                }\n            }\n        }\n        res.statusCode = 404;\n        res.setHeader(\"Content-Type\", \"application/json\");\n        res.write(JSON.stringify({ title: \"Not Found\", message: \"Route Not Found\" }));\n        res.end();\n    }\n\n    public addMiddleware(middleware: Handler) {\n        for (const route of this.routes) {\n            route[1].forEach((endPoint) => {\n                endPoint.handlers.unshift(middleware);\n            });\n        }\n    }\n\n    private async runHandlers(handlers: Array<Handler>, req: IncomingMessage, res: ServerResponse) {\n        let index = 0;\n        const next = async () => {\n            if (index < handlers.length) {\n                const handler = handlers[index++];\n                await handler(req, res, next);\n            }\n        };\n        await next();\n    }\n\n    private match(url: string, req: IncomingMessage): boolean {\n        const urlPath = url.split(\"/\");\n        const reqUrlPath = req.url?.split(\"/\") || [];\n\n        if (urlPath.length !== reqUrlPath.length) return false;\n\n        for (let i = 0; i < urlPath.length; i++) {\n            if (urlPath[i][0] === ':') {\n                req.params[urlPath[i].slice(1)] = reqUrlPath[i];\n                continue;\n            }\n            if (urlPath[i] !== reqUrlPath[i]) return false;\n        }\n        return true;\n    }\n\n    private set(method: string, url: string, handlers: Array<Handler>): void {\n        if (!this.routes.has(method)) {\n            this.routes.set(method, []);\n        }\n        this.routes.get(method)!.push({ url, handlers });\n    }\n\n    public get(url: string, ...handlers: Array<Handler>): void {\n        this.set(\"GET\", url, handlers);\n    }\n\n    public post(url: string, ...handlers: Array<Handler>): void {\n        this.set(\"POST\", url, handlers);\n    }\n\n    public put(url: string, ...handlers: Array<Handler>): void {\n        this.set(\"PUT\", url, handlers);\n    }\n\n    public delete(url: string, ...handlers: Array<Handler>): void {\n        this.set(\"DELETE\", url, handlers);\n    }\n\n    public startServer(port: number) {\n        const server = http.createServer(async (req: IncomingMessage, res: ServerResponse) => {\n            req.params = {};\n\n            await this.use(req, res);\n        });\n\n        server.listen(port, () => {\n            console.log(`Server started on port: ${port}`);\n        });\n    }\n}\n\nexport default Router;\nexport {Handler, IncomingMessage}"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,kBAAgD;AAChD,WAAsB;AAgBtB,IAAM,SAAN,MAAa;AAAA,EAGT,YAAY,UAAoB,CAAC,GAAG;AAChC,UAAM,aAAa,QAAQ,QAAQ,YAAU,CAAC,GAAG,OAAO,OAAO,QAAQ,CAAC,CAAC;AACzE,SAAK,SAAS,IAAI,IAAI,UAAU;AAAA,EACpC;AAAA,EAEa,IAAI,KAAsB,KAAqB;AAAA;AACxD,YAAM,eAAe,KAAK,OAAO,IAAI,IAAI,UAAU,EAAE;AACrD,UAAI,cAAc;AACd,mBAAW,YAAY,cAAc;AACjC,cAAI,KAAK,MAAM,SAAS,KAAK,GAAG,GAAG;AAC/B,kBAAM,KAAK,YAAY,SAAS,UAAU,KAAK,GAAG;AAClD;AAAA,UACJ;AAAA,QACJ;AAAA,MACJ;AACA,UAAI,aAAa;AACjB,UAAI,UAAU,gBAAgB,kBAAkB;AAChD,UAAI,MAAM,KAAK,UAAU,EAAE,OAAO,aAAa,SAAS,kBAAkB,CAAC,CAAC;AAC5E,UAAI,IAAI;AAAA,IACZ;AAAA;AAAA,EAEO,cAAc,YAAqB;AACtC,eAAW,SAAS,KAAK,QAAQ;AAC7B,YAAM,CAAC,EAAE,QAAQ,CAAC,aAAa;AAC3B,iBAAS,SAAS,QAAQ,UAAU;AAAA,MACxC,CAAC;AAAA,IACL;AAAA,EACJ;AAAA,EAEc,YAAY,UAA0B,KAAsB,KAAqB;AAAA;AAC3F,UAAI,QAAQ;AACZ,YAAM,OAAO,MAAY;AACrB,YAAI,QAAQ,SAAS,QAAQ;AACzB,gBAAM,UAAU,SAAS,OAAO;AAChC,gBAAM,QAAQ,KAAK,KAAK,IAAI;AAAA,QAChC;AAAA,MACJ;AACA,YAAM,KAAK;AAAA,IACf;AAAA;AAAA,EAEQ,MAAM,KAAa,KAA+B;AA5D9D;AA6DQ,UAAM,UAAU,IAAI,MAAM,GAAG;AAC7B,UAAM,eAAa,SAAI,QAAJ,mBAAS,MAAM,SAAQ,CAAC;AAE3C,QAAI,QAAQ,WAAW,WAAW,OAAQ,QAAO;AAEjD,aAAS,IAAI,GAAG,IAAI,QAAQ,QAAQ,KAAK;AACrC,UAAI,QAAQ,CAAC,EAAE,CAAC,MAAM,KAAK;AACvB,YAAI,OAAO,QAAQ,CAAC,EAAE,MAAM,CAAC,CAAC,IAAI,WAAW,CAAC;AAC9C;AAAA,MACJ;AACA,UAAI,QAAQ,CAAC,MAAM,WAAW,CAAC,EAAG,QAAO;AAAA,IAC7C;AACA,WAAO;AAAA,EACX;AAAA,EAEQ,IAAI,QAAgB,KAAa,UAAgC;AACrE,QAAI,CAAC,KAAK,OAAO,IAAI,MAAM,GAAG;AAC1B,WAAK,OAAO,IAAI,QAAQ,CAAC,CAAC;AAAA,IAC9B;AACA,SAAK,OAAO,IAAI,MAAM,EAAG,KAAK,EAAE,KAAK,SAAS,CAAC;AAAA,EACnD;AAAA,EAEO,IAAI,QAAgB,UAAgC;AACvD,SAAK,IAAI,OAAO,KAAK,QAAQ;AAAA,EACjC;AAAA,EAEO,KAAK,QAAgB,UAAgC;AACxD,SAAK,IAAI,QAAQ,KAAK,QAAQ;AAAA,EAClC;AAAA,EAEO,IAAI,QAAgB,UAAgC;AACvD,SAAK,IAAI,OAAO,KAAK,QAAQ;AAAA,EACjC;AAAA,EAEO,OAAO,QAAgB,UAAgC;AAC1D,SAAK,IAAI,UAAU,KAAK,QAAQ;AAAA,EACpC;AAAA,EAEO,YAAY,MAAc;AAC7B,UAAM,SAAc,kBAAa,CAAO,KAAsB,QAAwB;AAClF,UAAI,SAAS,CAAC;AAEd,YAAM,KAAK,IAAI,KAAK,GAAG;AAAA,IAC3B,EAAC;AAED,WAAO,OAAO,MAAM,MAAM;AACtB,cAAQ,IAAI,2BAA2B,IAAI,EAAE;AAAA,IACjD,CAAC;AAAA,EACL;AACJ;AAEA,IAAO,cAAQ;","names":[]}